import torch
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import ScalarFormatter
import seaborn as sns
from eval_scripts.eval_utils import *
from typing import Dict

def plot_historgrams(vae_surfaces, vae_values, realized_value, vae_ex_feats=None, realized_ex_feats=None, bin_count=15, row=2, col=1):
    '''
    Inputs: 
    - vae_surfaces: not really used in the calculation, returned only
    - vae_values: the values of surf[row, col] generated by the VAE model
    '''
    moneyness_grid=[0.7, 0.85, 1, 1.15, 1.3]
    ttm_grid=[0.08333, 0.25, 0.5, 1, 2]

    x_ticker_formatter = ScalarFormatter(useMathText=True)
    x_ticker_formatter.set_powerlimits((0, 0))

    # Create a separate plot to highlight the bar containing the realized value
    if vae_ex_feats is not None:
        plot_args = [{
                        "values": vae_values, 
                        "realized": realized_value,
                        "title": f"Histogram of VAE Point Values (Realized Highlighted) for \nPoint (Moneyness = {moneyness_grid[col]}, TTM = {ttm_grid[row]})"
                      },
                      {
                        "values": vae_ex_feats, 
                        "realized": realized_ex_feats,
                        "title": "Histogram of VAE Ex Values (Realized Highlighted)"
                      }]
        fig, ax = plt.subplots(1, 2, figsize=(11, 5))
        for i, plot_arg in enumerate(plot_args):
            sns.histplot(plot_arg["values"], bins=bin_count, ax=ax[i], color="skyblue")
            bin_edges = ax[i].patches[0].get_bbox().get_points()[:, 0]
            bin_width = bin_edges[1] - bin_edges[0]
            bin_index = int((plot_arg["realized"] - bin_edges[0]) // bin_width)
            if 0 <= bin_index < len(ax[i].patches):
                ax[i].patches[bin_index].set_facecolor("red")
            ax[i].xaxis.set_major_formatter(x_ticker_formatter)
            ax[i].set_xlabel("Value")
            ax[i].set_ylabel("Frequency")
            ax[i].set_title(plot_arg["title"])

        plt.tight_layout()
        plt.show()
        return vae_surfaces, vae_values, realized_value, vae_ex_feats
    else:
        fig, ax = plt.subplots(1, 1, figsize=(5, 5))
        sns.histplot(vae_values, bins=bin_count, ax=ax, color="skyblue")
        bin_edges = ax.patches[0].get_bbox().get_points()[:, 0]
        bin_width = bin_edges[1] - bin_edges[0]
        skew_bin_index = int((realized_value - bin_edges[0]) // bin_width)
        if 0 <= skew_bin_index < len(ax.patches):
            ax.patches[skew_bin_index].set_facecolor("red")
        ax.xaxis.set_major_formatter(x_ticker_formatter)
        ax.set_xlabel("Value")
        ax.set_ylabel("Frequency")
        ax.set_title(f"Histogram of VAE Point Values (Realized Highlighted) for Point (Moneyness = {moneyness_grid[col]}, TTM = {ttm_grid[row]})")

        plt.tight_layout()
        plt.show()
        return vae_surfaces, vae_values, realized_value


def generate_multiple_surfaces_distributions(model_data, ex_data, vol_surface_data, 
                                             day, row, col, num_vaes, 
                                             model_type: Union[CVAE, CVAEMem] = CVAEMem, 
                                             check_ex_feats=False, bin_count=15, ctx_len=None):
    '''
    Input:
    - model: trained model for vae vol surface
    - ex_data, vol_surface_data: pre-generated latent samples return/price and surfaces data. If SABR data has multiple paths, need to select the path before passing in.
    - day: MUST day > ctx_len
    - num_vaes: number of vaes to generate
    - row, col: point on vae surfaces wish to view. 0<=row<num_ttm, 0<=col<num_moneyness
    - check_ex_feats: whether or not we check the distribution of extra features like return/price, default False,  if True, will plot 2 separate distributions
    - bin_count: number of bins to characterize the histogram, default: 15
    
    Returns:
    - vae_surfaces: generated surfaces (num_vaes, num_ttm, num_moneyness)
    - vae_values: value on vae surfaces at (row, col)
    - realized_value: real value on vae surfaces at (row, col)
    '''
    model_config = model_data["model_config"]
    model = model_type(model_config)
    model.load_weights(dict_to_load=model_data)
    if ctx_len is None:
        seq_len = model_config["seq_len"]
        ctx_len = model_config["ctx_len"]

    if "ex_feats_dim" in model_config:
        use_ex_feats = model_config["ex_feats_dim"] > 0
    else:
        use_ex_feats = False
    print("use_ex_feats is: ",use_ex_feats)

    vae_surfaces, vae_ex_feats = generate_surfaces(model, ex_data, vol_surface_data, day, ctx_len, num_vaes, use_ex_feats, check_ex_feats)

    realized_value = vol_surface_data[day, row, col]
    vae_values = vae_surfaces[:, row, col]

    return plot_historgrams(vae_surfaces, vae_values, realized_value, vae_ex_feats, ex_data[day], bin_count, row, col)

def compute_mse_plot(real_surface, day, vae_surfaces_of_day):
  '''
  input:
  real_surface: realized surfaces, need to specify the day we are comparing and should be the same as the VAE surface days
  day: day in path of realize surface, should be the same
  vae_surfaces_of_day: # of generated vae surfaces created for the day of comparison
  output:
  --plots 5 best surfcaes with lowest MSEs
  BestMSEs: dictionary best surfaces: 5 best surfaces in np matrix, and best MSE score attached with it
  '''
  # Convert the realized surface to a PyTorch tensor
  realized_surface = torch.from_numpy(real_surface[day])

  # Compute the MSE between each VAE surface and the realized surface
  mse_scores = []
  for surface in vae_surfaces_of_day:
      mse = torch.mean((surface - realized_surface) ** 2)
      mse_scores.append(mse.item())

  # Sort the MSE scores and get the indices of the 5 best surfaces
  indices = np.argsort(mse_scores)[:5]

  # Create a dictionary to store the 5 best surfaces and their corresponding MSE scores
  best_mses = {}
  for index in indices:
      best_mses[index] = {
          'surface': vae_surfaces_of_day[index].numpy(),
          'mse': mse_scores[index]
      }

  return best_mses

def compute_pointwise_error_histogram(real_surface: np.ndarray, vae_surfaces: np.ndarray, plot_type="kde"):
    '''
    Computes the point-wise squared error between a point on the realized surface and each VAE surface.
    Creates a histogram for each point-wise squared error.
    If we look at multiple days, i.e. len(real_surface.shape) == 3, we combine across days

    Inputs:
    - real_surface: Realized surface of the day, numpy array of shape (num_day: optional, num_ttm, num_moneyness)
    - vae_surfaces_of_day: List of VAE surfaces generated for the same day, each with shape (num_day: optional, num_samples, num_ttm, num_moneyness)
    - plot_type: "kde" (smoothed), "hist" (histogram plot)

    Outputs:
    - None (plots the histograms)
    '''
    multi_day = len(real_surface.shape) == 3
    if len(real_surface.shape) == 3:
        _, num_rows, num_cols = real_surface.shape
        assert len(vae_surfaces.shape) == 4 and vae_surfaces.shape[0] == real_surface.shape[0], "num_day dimension mismatch"
    else:
        num_rows, num_cols = real_surface.shape

    # Extract the point on the realized surface
    moneyness_grid=[0.7, 0.85, 1, 1.15, 1.3]
    ttm_grid=[0.08333, 0.25, 0.5, 1, 2]

    # Calculate the point-wise squared error between the realized point and each VAE surface point
    squared_errors = []
    if multi_day:
        for d in range(real_surface.shape[0]):
            real_surface_of_day = real_surface[d]
            vae_surfaces_of_day = vae_surfaces[d]
            for surface in vae_surfaces_of_day:
                pointwise_error = (surface - real_surface_of_day) ** 2
                squared_errors.append(pointwise_error)
    else:
        for surface in vae_surfaces:
            pointwise_error = (surface - real_surface) ** 2
            squared_errors.append(pointwise_error)

    # Create a histogram for each point-wise squared error
    x_ticker_formatter = ScalarFormatter(useMathText=True)
    x_ticker_formatter.set_powerlimits((0, 0))
    fig, ax = plt.subplots(num_rows, num_cols, figsize=(20, 20))
    for row in range(num_rows):
        for col in range(num_cols):
            curr_ax = ax[row, col]
            errors = [squared_error[row, col] for squared_error in squared_errors]
            if plot_type == "kde":
                sns.kdeplot(data=errors, ax=curr_ax)
            else:
                sns.histplot(data=errors, ax=curr_ax)
            curr_ax.set_xlabel('Squared Error')
            curr_ax.set_ylabel('Frequency')
            curr_ax.set_title(f'Moneyness={moneyness_grid[col]}\nTTM = {ttm_grid[row]}')
            curr_ax.xaxis.set_major_formatter(x_ticker_formatter)
    fig.suptitle("Point-wise Squared Error", fontsize="xx-large", fontweight="heavy")
    fig.tight_layout()
    fig.subplots_adjust(top=0.93)
    plt.show()

def skew_and_slope_metrics(realized_surface, vae_surfaces, bin_count=15):
    '''
        In this function, we plot the probability distributions from vae_surfaces of the following attributes: 
        - skew: (iv[1 ytm, K/S=0.85] + iv[1 ytm, K/S=1.15])/2 - iv[1 ytm, K/S=1]
        - slope: (iv[2 ytm, K/S=1] - iv[3 mtm, K/S=1])
        - Joint probability of both metrics

        Then, we find where these values of the realized surface lie in the distributions.

        Inputs:
        - realized_surface: realized surface of the day, shape (num_ttm, num_moneyness)
        - vae_surfaces: samples of vae surfaces of the day, shape (num_samples, num_ttm, num_moneyness)
        - bin_count: number of bins to characterize the histogram, default: 15
    '''
    # calculate the skew as (iv[1 ytm, K/S=0.85] + iv[1 ytm, K/S=1.15])/2 - iv[1 ytm, K/S=1]
    realized_skew = (realized_surface[3, 1] + realized_surface[3, 3]) / 2 - realized_surface[3, 2]
    vae_skews = (vae_surfaces[:, 3, 1] + vae_surfaces[:, 3, 3]) / 2 - vae_surfaces[:, 3, 2]
    # calculate the slope as (iv[2 ytm, K/S=1] - iv[3 mtm, K/S=1])
    realized_slope = realized_surface[4, 2] - realized_surface[1, 2]
    vae_slopes = vae_surfaces[:, 4, 2] - vae_surfaces[:, 1, 2]

    joint_dist, joint_bin_splits = np.histogramdd(np.array([vae_skews, vae_slopes]).transpose(), bins=[bin_count, bin_count])

    x_ticker_formatter = ScalarFormatter(useMathText=True)
    x_ticker_formatter.set_powerlimits((0, 0))
    plot_args = [{
            "values": vae_skews, 
            "realized": realized_skew,
            "xlabel": "Skew",
            "title": "Volatility skew distribution"
        },
        {
            "values": vae_slopes, 
            "realized": realized_slope,
            "xlabel": "Slope",
            "title": "Volatility slop distribution"
    }]
    fig, ax = plt.subplots(1, 3, figsize=(16, 5))

    bin_indices = []
    bin_valid = []
    for i, plot_arg in enumerate(plot_args):
        sns.histplot(plot_arg["values"], bins=bin_count, ax=ax[i], color="skyblue")
        bin_edges = ax[i].patches[0].get_bbox().get_points()[:, 0]
        bin_width = bin_edges[1] - bin_edges[0]
        bin_index = int((plot_arg["realized"] - bin_edges[0]) // bin_width)
        bin_indices.append(bin_index)
        if 0 <= bin_index < len(ax[i].patches):
            ax[i].patches[bin_index].set_facecolor("red")
            bin_valid.append(True)
        else:
            bin_valid.append(False)
        ax[i].xaxis.set_major_formatter(x_ticker_formatter)
        ax[i].set_xlabel(plot_arg["xlabel"])
        ax[i].set_ylabel("Frequency")
        ax[i].set_title(plot_arg["title"])

    sns.heatmap(joint_dist.T, cmap="Blues", ax=ax[2], annot=True)
    if all(bin_valid):
        mask = np.zeros_like(joint_dist, dtype=bool)
        mask[tuple(bin_indices)] = True
        sns.heatmap(joint_dist.T, cmap=["red", "white"], mask=~mask.T, annot=True, cbar=False, ax=ax[2])
    ax[2].set_xticklabels([f"{x:.3f}" for x in joint_bin_splits[0][:-1]], rotation=90)
    ax[2].set_yticklabels([f"{x:.3f}" for x in joint_bin_splits[1][:-1]], rotation=0)
    ax[2].set_xlabel("Skew")
    ax[2].set_ylabel("Slope")
    ax[2].set_title("Joint distribution")
    plt.tight_layout()
    plt.show()

def latent_manipulation_check(model: CVAEMemRand, context: Dict[str, torch.Tensor], 
                              base_z: torch.Tensor, index_to_change, z_value_range=[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]):
    '''
    check how the surface generated by the model changes based on a specific change in 1 latent dimension of the day to generate

    Inputs:
        model: the model to evaluate, must have model config consistent with base_z and context
        context: context dictionary, "surface" have shape (C,H,W), "ex_feats" have shape (C, ex_feats_dim)
        base_z: the latent vector to manipulate from, of shape (B, T, latent_dim), T is better to be chosen as 2, C=T-1 as defined by the model
        index_to_change: which index of base_z we should vary
        z_value_range: what are the z_values to take for this specific index
    Returns:
        A dictionary {
            "surface": An np array of shape (B*len(z_value_range), T-C, H, W),
            "ex_feats": An np array of shape (B*len(z_value_range), T-C, ex_feats_dim), if model.config["ex_feats_dim"] > 0 and model.config["re_feat_weight"] > 0
        }
    '''
    use_ex_feats = model.config["ex_feats_dim"] > 0
    output_ex_feats = use_ex_feats and model.config["re_feat_weight"] > 0
    surfaces = context["surface"]
    assert len(surfaces.shape) == 3, "doesn't support multiple batches"
    surface_outputs = []
    if output_ex_feats:
        ex_feats_outputs = []
    for z_val in z_value_range:
        curr_z = base_z.clone().detach()
        curr_z[0, -1, index_to_change] = z_val
        if use_ex_feats:
            surf, ex = model.get_surface_given_conditions(context, base_z)
            surface_outputs.append(surf.detach().cpu().numpy().reshape((5,5)))
            if output_ex_feats:
                ex_feats_outputs.append(ex.detach().cpu().numpy().reshape((model.config["ex_feats_dim"],)))
        else:
            surf = model.get_surface_given_conditions(context, base_z)
            surface_outputs.append(surf.detach().cpu().numpy().reshape((5,5)))
    if output_ex_feats:
        return  {
            "surface": np.array(surface_outputs),
            "ex_feats": np.array(ex_feats_outputs),
        }
    else:
        return  {
            "surface": np.array(surface_outputs),
        }

def latent_manipulation_check(model: CVAEMemRand, context: Dict[str, torch.Tensor], 
                              base_z: torch.Tensor, index_to_change, z_value_range=[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]):
    '''
    check how the surface generated by the model changes based on a specific change in 1 latent dimension of the day to generate

    Inputs:
        model: the model to evaluate, must have model config consistent with base_z and context
        context: context dictionary, "surface" have shape (C,H,W), "ex_feats" have shape (C, ex_feats_dim)
        base_z: the latent vector to manipulate from, of shape (B, T, latent_dim), T is better to be chosen as 2, C=T-1 as defined by the model
        index_to_change: which index of base_z we should vary
        z_value_range: what are the z_values to take for this specific index
    Returns:
        A dictionary {
            "surface": An np array of shape (B*len(z_value_range), T-C, H, W),
            "ex_feats": An np array of shape (B*len(z_value_range), T-C, ex_feats_dim), if model.config["ex_feats_dim"] > 0 and model.config["re_feat_weight"] > 0
        }
    '''
    use_ex_feats = model.config["ex_feats_dim"] > 0
    output_ex_feats = use_ex_feats and model.config["re_feat_weight"] > 0
    surfaces = context["surface"]
    assert len(surfaces.shape) == 3, "doesn't support multiple batches"
    surface_outputs = []
    if output_ex_feats:
        ex_feats_outputs = []
    for z_val in z_value_range:
        curr_z = base_z.clone().detach()
        curr_z[0, -1, index_to_change] = z_val
        if use_ex_feats:
            surf, ex = model.get_surface_given_conditions(context, base_z)
            surface_outputs.append(surf.detach().cpu().numpy().reshape((5,5)))
            if output_ex_feats:
                ex_feats_outputs.append(ex.detach().cpu().numpy().reshape((model.config["ex_feats_dim"],)))
        else:
            surf = model.get_surface_given_conditions(context, base_z)
            surface_outputs.append(surf.detach().cpu().numpy().reshape((5,5)))
    if output_ex_feats:
        return  {
            "surface": np.array(surface_outputs),
            "ex_feats": np.array(ex_feats_outputs),
        }
    else:
        return  {
            "surface": np.array(surface_outputs),
        }

def plot_surface_slice_different_latents(results, realized, z_value_range=[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]):
    color_list = ["red", "orange", "yellow", "green", "blue", "purple", "pink", "gray", "black"]
    moneyness_grid=[0.7, 0.85, 1, 1.15, 1.3]
    ttm_grid=[0.08333, 0.25, 0.5, 1, 2]
    fig, ax = plt.subplots(len(results), 2, figsize=(10, 5 * len(results) + 3))
    for latent_idx in range(len(results)):
        ax[latent_idx, 0].set_xlabel("K/S")
        ax[latent_idx, 0].set_ylabel("iv")
        ax[latent_idx, 0].set_title(f"IV slice with ttm=1,\nlatent change {latent_idx}")
        ax[latent_idx, 1].set_xlabel("ttm")
        ax[latent_idx, 1].set_ylabel("iv")
        ax[latent_idx, 1].set_title(f"IV slice with K/S=1,\nlatent change {latent_idx}")
    for latent_idx, result in enumerate(results):
        surface = result["surface"]
        ttm_slices = surface[:, 3, :]
        moneyness_slices = surface[:, :, 2]
        for z_val_idx, z_value in enumerate(z_value_range):
            ax[latent_idx, 0].plot(moneyness_grid, ttm_slices[z_val_idx], label=f"latent={z_value}", color=color_list[z_val_idx])
            ax[latent_idx, 1].plot(ttm_grid, moneyness_slices[z_val_idx], label=f"latent={z_value}", color=color_list[z_val_idx])
        ax[latent_idx, 0].plot(moneyness_grid, realized[3, :], label=f"realized", color="black", linestyle="dashed")
        ax[latent_idx, 1].plot(ttm_grid, realized[:, 2], label=f"realized", color="black", linestyle="dashed")
    for latent_idx in range(len(results)):
        ax[latent_idx, 0].legend(frameon = False)
        ax[latent_idx, 1].legend(frameon = False)
    plt.tight_layout()
    plt.show()

def plot_surface_slice_different_latents_single_latent(result, realized, latent_i,
                                                       z_value_range=[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]):
    color_list = ["red", "orange", "yellow", "green", "blue", "purple", "pink", "gray", "black"]
    moneyness_grid=[0.7, 0.85, 1, 1.15, 1.3]
    ttm_grid=[0.08333, 0.25, 0.5, 1, 2]
    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    ax[0].set_xlabel("K/S")
    ax[0].set_ylabel("iv")
    ax[0].set_title(f"IV slice with ttm=1,\nlatent change {latent_i}")
    ax[1].set_xlabel("ttm")
    ax[1].set_ylabel("iv")
    ax[1].set_title(f"IV slice with K/S=1,\nlatent change {latent_i}")

    surface = result["surface"]
    ttm_slices = surface[:, 3, :]
    moneyness_slices = surface[:, :, 2]
    for z_val_idx, z_value in enumerate(z_value_range):
        ax[0].plot(moneyness_grid, ttm_slices[z_val_idx], label=f"latent={z_value}", color=color_list[z_val_idx])
        ax[1].plot(ttm_grid, moneyness_slices[z_val_idx], label=f"latent={z_value}", color=color_list[z_val_idx])
    ax[0].plot(moneyness_grid, realized[3, :], label=f"realized", color="black", linestyle="dashed")
    ax[1].plot(ttm_grid, realized[:, 2], label=f"realized", color="black", linestyle="dashed")
    
    ax[0].legend(frameon = False)
    ax[1].legend(frameon = False)
    plt.tight_layout()
    plt.show()

def plot_ret_different_latents(results, realized, z_value_range=[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]):
    for latent_idx, result in enumerate(results):
        ret = result["ex_feats"][:, 0]
        plt.plot(z_value_range, ret, label=f"latent={latent_idx}")
    plt.plot(z_value_range, np.ones_like(z_value_range) * realized, label=f"realized", color="black", linestyle="dashed")
    plt.xlabel("z value")
    plt.ylabel("Ret")
    plt.title("Ret vs z value change, for different latent indices")
    plt.legend(frameon = False)
    plt.tight_layout()
    plt.show()